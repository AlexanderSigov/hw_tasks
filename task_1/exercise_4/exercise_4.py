import copy

"""
№ 1 Глубокое и поверхностное копирование
Напишите функцию, которая демонстрирует различие между неглубоким (shallow) и глубоким (deep) копированием сложных объектов в Python.
Для этого вам нужно:
Создать двумерный список original, содержащий два вложенных списка 1,2,3 и 4,5,6.
Использовать встроенные модули для создания неглубокой и глубокой копии этого списка.
Изменить самый первый элемент вложенного списка на 99.
вернуть результат shallow и deep_copy
"""

def copy_comparison():
    pass

"""
№ 2 Изменение элементов в списке и попытка изменения элементов в кортеже
Объявить список длиной 3 и кортеж длиной 3.
В первом списке изменить первый элемент на 99.
В кортеже попытаться присвоить первому элементу тоже 99, но предусмотреть исключение TypeError.
Вернуть список, кортеж и ошибку для присвоения значения в кортеже.
"""

def modify_elements():
    pass

"""
№ 3 Создание списка кортежей с помощью zip и enumerate
"""

def create_tuples(list1: list, list2: list) -> list:
    return pass # решение в одну строку

"""
№ 4 Вычисление факториала с помощью обычной функции и генератора
"""

# Обычная функция
def factorial(n: int) -> int:
    pass


# Генератор
def factorial_generator(n: int): # использовать yield
    pass


"""
№ 5 Определение принадлежности пакета через код
"""
# Заполнить одним из значений library/framework/module/unknown
packages = {
    "numpy": "unknown",
    "pandas": "unknown",
    "django": "unknown",
    "flask": "unknown",
    "math": "unknown",
    "itertools": "unknown",
}

# на вход название модуля/библиотеки/фреймворка
def classify_package(pkg_name: str) -> str:
    return pass # определение, чем является строковый объект, если не известно, то вернуть сначение `unknown`


"""
№ 6 Реализация классов с динамическим полиморфизмом и данных скрытием

Реализовать метод do_work в классе Programmer который возвращает строку `Writing code`
Реализовать метод do_work в классе Designer который возвращает строку `Designing interface`
"""


# Полиморфизм через метод do_work()
class Worker:
    def do_work(self):
        raise NotImplementedError


class Programmer(Worker):
    pass


class Designer(Worker):
    pass


# Инкапсуляция: скрытие реализации с использованием методов доступа
# При инициализации оъекта класса PrivateAccount объявить приватный атрибут balance
# Реализовать метод get_balance возвращающий приватный атрибут текущего баланса
# Реализовать метод deposit с возможностью внесения указанной суммы условной единицы
class PrivateAccount:
    pass
