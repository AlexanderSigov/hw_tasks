import logging
import time
from collections.abc import Iterable
from typing import Any, Callable, Dict, Iterable, List, Optional, Set

"""
№ 1 Создание контекстного менеджера для логирования выполнения кода

Реализуйте контекстный менеджер,
который замеряет время выполнения блока кода и записывает это время в лог.
Используйте класс ExecutionTimer, который должен поддерживать следующие функции:

Класс должен реализовывать методы __enter__ и __exit__.
Вход в контекстный менеджер должен начать отсчет времени, а выход — остановить и зафиксировать время выполнения в секундах.

Выбор типа времени: В классе предусмотрите возможность замера либо реального времени выполнения (по умолчанию),
либо процессорного времени (при установке соответствующего флага).
Это может быть полезно для более точной оценки времени работы CPU на длинных операциях.

Журналирование: В процессе работы класса ведите журнал с помощью модуля logging.

При входе в контекст: запишите сообщение о начале выполнения блока. сообщение `Execution started.`
При выходе из контекста: запишите время выполнения. сообщение `Execution finished in время seconds.`
В случае исключений: зафиксируйте возникшую ошибку в логах. сообщение `An exception occurred: ошибка`
Хранение времени выполнения: Реализуйте механизм сохранения всех измеренных временных интервалов в списке execution_times. Это нужно для подсчета среднего времени выполнения нескольких блоков кода.

Среднее время выполнения: Добавьте метод average_execution_time,
который возвращает среднее время выполнения всех замеров (либо 0, если замеров ещё не было).
"""

# логгирование
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")


class ExecutionTimer:
    pass


"""
№ 2  Поиск общих элементов в двух наборах (set)

Реализуйте функцию для нахождения общих элементов в нескольких множествах,
поддерживая как простые типы данных, так и вложенные структуры данных (вложенные множества, списки и кортежи).
Ваше решение должно корректно обрабатывать вложенные итерабельные объекты и поддерживать рекурсивное нахождение пересечений в этих структурах.

Напишите функцию deep_intersection(set1: Set, set2: Set), которая находит пересечение между двумя множествами.
Если элемент в обоих множествах также является множеством или итерабельным объектом, функция должна рекурсивно искать пересечения внутри этих элементов.
Напишите функцию find_common_elements_recursive(*sets: List[Set]), которая находит пересечение в нескольких множествах.
Функция должна работать с произвольным количеством аргументов и вызывать рекурсивно функцию deep_intersection для каждого множества.
Программа должна корректно работать для всех типов итерабельных объектов, таких как множества, списки, кортежи, но игнорировать строки и байтовые объекты.
Если пересечение пустое, функция должна возвращать пустое множество.
"""


def deep_intersection(set1: Set, set2: Set) -> Set:
    result = set()
    pass


def find_common_elements_recursive(*sets: List[Set]) -> Set:
    pass


"""
№ 3  Напишите функцию lists_to_dict,
которая принимает два списка: keys и values.
Функция должна преобразовывать эти списки в словарь, где элементы из keys становятся ключами,
а элементы из values становятся значениями.

Если количество ключей больше количества значений,
функция должна добавлять недостающие значения как None.
Если же количество значений превышает количество ключей, функция должна обрезать лишние значения.
"""


def lists_to_dict(keys: List[Any], values: List[Any]) -> Dict[Any, Any]:
    pass


"""
№ 4 Позиционные аргументы и аргументы с именем, их воздействие на результат

Напишите функцию combine_strings, которая объединяет список строк в одну строку. Функция должна принимать три аргумента:

strings: список строк (List[str]), который нужно объединить.
transform_func: необязательная функция (Optional[Callable[[str], str]]), которая будет применяться к каждой строке перед объединением. Если не передана, строки объединяются без изменений.
delimiter: строка-разделитель (str), которая будет вставлена между строками. По умолчанию это пустая строка.

Проверить, что все элементы в strings являются строками. Если это не так, вызвать исключение ValueError с сообщением "All elements in the list must be strings."
Если передана функция трансформации, убедиться, что она является вызываемым объектом. Если нет, вызвать исключение ValueError с сообщением "Transform function must be callable."
Если функция трансформации предоставлена, применить её к каждой строке в списке strings.
Объединить строки из списка с использованием delimiter в качестве разделителя и вернуть результат.
"""


def combine_strings(
    strings: List[str],
    transform_func: Optional[Callable[[str], str]] = None,
    delimiter: str = "",
) -> str:
    pass


"""
№ 5 реализовать иерархию классов для работы с медиа-контентом.
У вас есть три типа медиа-контента: общие медиа (Media), музыка (Music) и видео (Video).
Каждый из этих типов медиа должен поддерживать базовые операции, такие как воспроизведение,
пауза и получение информации.

Базовый класс Media:

Свойства:
title (строка) – название медиа.
duration (строка) – продолжительность медиа.
_is_playing (логическое) – состояние воспроизведения (изначально False).
Методы:
play() – начинает воспроизведение медиа. Если медиа уже воспроизводится, возвращает сообщение `произведение is already playing`. Если нет – изменяет состояние и возвращает сообщение о начале воспроизведения `Playing произведение`.
pause() – ставит медиа на паузу. Если медиа не воспроизводится, возвращает сообщение `произведение is not playing`. Если воспроизводится – изменяет состояние и возвращает сообщение `Paused произведение`.
get_info() – возвращает строку с информацией о названии и продолжительности медиа (`Title: произведение, Duration: длительность`).

Класс Music (наследуется от Media):

Свойства:
genre (строка) – жанр музыки.
Методы:
Переопределяет метод play(), чтобы возвращать сообщение о воспроизведении музыки с указанием жанра.
(`произведение (Music) is already playing`), (`Playing music: произведение in genre жанр`)


Класс Video (наследуется от Media):
Свойства:
resolution (строка) – разрешение видео.
Методы:
Переопределяет метод play(), чтобы возвращать сообщение о воспроизведении видео с указанием разрешения.
(`произведение (Video) is already playing`), (`Playing video: произведение in resolution разрешение`)
"""


class Media:
    pass


class Music(Media):
    pass


class Video(Media):
    pass


"""
№ 6 Реализация кастомного стека с магическими методами __str__, __iter__

Реализовать класс CustomStack, представляющий собой стек.
Стек — это структура данных, которая следует принципу "последний пришёл — первый вышел" (LIFO).
Ваша реализация должна включать следующие методы:

Конструктор __init__:

Создайте пустой стек.
Метод push(item):

Добавляет элемент item на верх стека.
Метод pop():

Удаляет и возвращает элемент с вершины стека.
Если стек пуст, выбрасывает исключение StackError с сообщением "Pop from an empty stack".

Метод peek():

Возвращает элемент с вершины стека, не удаляя его.
Если стек пуст, выбрасывает исключение StackError с сообщением "Peek from an empty stack".
Метод is_empty():

Возвращает True, если стек пуст, и False в противном случае.
Метод __str__():

Возвращает строковое представление стека в виде списка.
Метод __iter__():

Позволяет итерировать элементы стека в порядке их добавления.
"""


class StackError(Exception):
    """Custom exception for stack errors."""

    pass


class CustomStack:
    pass
